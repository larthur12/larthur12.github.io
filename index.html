<!DOCTYPE html>

<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>FlowMath - AI Mastery System</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
/* 全域禁止捲動彈性與縮放，解決 iPad 反白問題 /
body {
overscroll-behavior-y: none;
touch-action: none;
-webkit-user-select: none; / Chrome/Safari /
-moz-user-select: none; / Firefox /
-ms-user-select: none; / IE10+ /
user-select: none; / Standard /
-webkit-touch-callout: none; / 禁止 iOS 長按選單 */


    /* 允許輸入框可以選取文字，解決文字模式無法輸入問題 */
    textarea, input {
        -webkit-user-select: text;
        user-select: text;
        -webkit-touch-callout: default;
    }

    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
</style>


</head>
<body class="bg-slate-50 text-slate-800 h-screen overflow-hidden">
<div id="root"></div>

<script type="text/babel">
    // ==========================================
    // 你的 API Key (拆分以避開 GitHub 掃描)
    // ==========================================
    const keyPart1 = "AIzaSyBJrpted3kQFGCQsaqfw";
    const keyPart2 = "-eHxAZ_R4VSTqY";
    const apiKey = keyPart1 + keyPart2;
    const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";

    const { useState, useRef, useEffect } = React;

    // --- Icon 組件 ---
    const Icon = ({ name, size = 20, className = "" }) => {
        let path = null;
        if (name === 'pen') path = <path d="M12 19l7-7 3 3-7 7-3-3zM18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z M2 2l7.586 7.586" />;
        if (name === 'eraser') path = <path d="M2.998 2.998A2 2 0 014.808 2h14.384a2 2 0 011.81 1.002l-8.598 17.196A2 2 0 0110.8 21H2.998a1 1 0 01-.81-1.002L6.586 11l-4.398-8.002z M7 12h8" />;
        if (name === 'check') path = <polyline points="20 6 9 17 4 12" />;
        if (name === 'chevronRight') path = <polyline points="9 18 15 12 9 6" />;
        if (name === 'refresh') path = <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" />;
        if (name === 'camera') path = <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />;
        if (name === 'play') path = <polygon points="5 3 19 12 5 21 5 3" />;
        if (name === 'send') path = <g><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></g>;
        if (name === 'keyboard') path = <g><rect x="2" y="4" width="20" height="16" rx="2" ry="2" /><line x1="6" y1="8" x2="6" y2="8" /><line x1="10" y1="8" x2="10" y2="8" /><line x1="14" y1="8" x2="14" y2="8" /><line x1="18" y1="8" x2="18" y2="8" /><line x1="6" y1="12" x2="6" y2="12" /><line x1="10" y1="12" x2="10" y2="12" /><line x1="14" y1="12" x2="14" y2="12" /><line x1="18" y1="12" x2="18" y2="12" /><line x1="7" y1="16" x2="17" y2="16" /></g>;
        
        return (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );
    };

    const SYSTEM_PROMPT = `
    You are FlowMath, an expert Socratic Math Tutor.
    Goal: Help student solve math problems using Text Discussion + Handwriting Analysis.
    [MODE 1: TEXT] Explain concepts simply. Use analogies.
    [MODE 2: HANDWRITING] Analyze steps. Identify logical errors. Do NOT give answers directly. Ask guiding questions.
    Keep responses concise (under 3 sentences).
    `;

    const FlowMathApp = () => {
        const [appState, setAppState] = useState('setup');
        const [problemContext, setProblemContext] = useState({ text: '', image: null });
        const [messages, setMessages] = useState([]);
        const [isThinking, setIsThinking] = useState(false);
        const [inputMode, setInputMode] = useState('canvas');
        const [inputText, setInputText] = useState('');
        const [panelHeight, setPanelHeight] = useState(320);
        const [tool, setTool] = useState('pen');
        const [brushColor, setBrushColor] = useState('#1e293b');
        const [isDrawing, setIsDrawing] = useState(false);

        const canvasRef = useRef(null);
        const ctxRef = useRef(null);
        const isDraggingPanel = useRef(false);
        const dragStartY = useRef(0);
        const dragStartHeight = useRef(0);
        const savedCanvasDataRef = useRef(null);

        const callGemini = async (inputPayload) => {
            if (!apiKey) return "請檢查 API Key";
            try {
                const historyPrompt = messages.slice(-6).map(m => 
                    `${m.sender === 'user' ? 'Student' : 'Tutor'}: ${m.text || '[Image]'}`
                ).join('\n');

                const fullPrompt = `
                [Problem]: ${problemContext.text}
                ${problemContext.image ? '[Image Attached]' : ''}
                [History]:
                ${historyPrompt}
                `;

                const contentsParts = [{ text: fullPrompt }];

                if (messages.length === 0 && problemContext.image) {
                    const base64Context = problemContext.image.split(',')[1];
                    contentsParts.push({ inlineData: { mimeType: "image/png", data: base64Context } });
                }

                if (inputPayload.type === 'text') {
                    contentsParts.push({ text: `[Question]: ${inputPayload.content}` });
                } else {
                    const base64Handwriting = inputPayload.content.split(',')[1];
                    contentsParts.push({ text: `[Handwriting]:` });
                    contentsParts.push({ inlineData: { mimeType: "image/png", data: base64Handwriting } });
                }

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: contentsParts }],
                            systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] }
                        })
                    }
                );

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "抱歉，請再試一次。";
            } catch (error) {
                console.error("AI Error:", error);
                return "連線錯誤或 API Key 無效。";
            }
        };

        const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => setProblemContext(prev => ({ ...prev, image: reader.result }));
                reader.readAsDataURL(file);
            }
        };

        const startSession = () => {
            setMessages([{
                id: 'init',
                sender: 'ai',
                text: '收到題目了！切換到「畫布模式」開始解題，或用「文字模式」討論觀念。',
            }]);
            setAppState('chat');
        };

        const handleDragStart = (e) => {
            isDraggingPanel.current = true;
            dragStartY.current = e.touches ? e.touches[0].clientY : e.clientY;
            dragStartHeight.current = panelHeight;
            if (canvasRef.current && ctxRef.current) {
                savedCanvasDataRef.current = ctxRef.current.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
            }
        };

        const handleDragMove = (e) => {
            if (!isDraggingPanel.current) return;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const deltaY = dragStartY.current - clientY;
            const newHeight = Math.min(Math.max(dragStartHeight.current + deltaY, 200), window.innerHeight * 0.8);
            setPanelHeight(newHeight);
        };

        const handleDragEnd = () => { isDraggingPanel.current = false; };

        useEffect(() => {
            if (appState !== 'chat' || inputMode !== 'canvas') return;
            const timer = setTimeout(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();

                if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
                     let tempSavedData = savedCanvasDataRef.current;
                     if (!isDraggingPanel.current && !tempSavedData && ctxRef.current) {
                        try { tempSavedData = ctxRef.current.getImageData(0, 0, canvas.width, canvas.height); } catch(e){}
                     }
                     canvas.width = rect.width * dpr;
                     canvas.height = rect.height * dpr;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(dpr, dpr);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
                    ctx.strokeStyle = brushColor;
                    ctx.lineWidth = tool === 'eraser' ? 20 : 3;
                    ctxRef.current = ctx;
                     if (tempSavedData) ctx.putImageData(tempSavedData, 0, 0);
                } else if (!ctxRef.current) {
                    const ctx = canvas.getContext('2d');
                    ctx.scale(dpr, dpr);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
                    ctx.strokeStyle = brushColor;
                    ctx.lineWidth = tool === 'eraser' ? 20 : 3;
                    ctxRef.current = ctx;
                }
                if (!isDraggingPanel.current) savedCanvasDataRef.current = null;
            }, 10);
            return () => clearTimeout(timer);
        }, [appState, inputMode, panelHeight, tool, brushColor]);

        const getPos = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cx - rect.left, y: cy - rect.top };
        };

        const startDrawing = (e) => {
            // 在繪圖時明確阻止事件冒泡和預設行為
            if (e.cancelable) e.preventDefault();
            if (!ctxRef.current) return;
            ctxRef.current.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            ctxRef.current.strokeStyle = brushColor;
            ctxRef.current.lineWidth = tool === 'eraser' ? 20 : 3;
            const { x, y } = getPos(e.nativeEvent || e);
            ctxRef.current.beginPath();
            ctxRef.current.moveTo(x, y);
            setIsDrawing(true);
        };

        const draw = (e) => {
            if (!isDrawing) return;
            if (e.cancelable) e.preventDefault();
            const { x, y } = getPos(e.nativeEvent || e);
            ctxRef.current.lineTo(x, y);
            ctxRef.current.stroke();
        };

        const stopDrawing = (e) => {
            if (e && e.cancelable) e.preventDefault();
            if (ctxRef.current) ctxRef.current.closePath();
            setIsDrawing(false);
        };

        const clearCanvas = () => {
            const ctx = ctxRef.current;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
            ctx.globalCompositeOperation = 'source-over';
            savedCanvasDataRef.current = null;
        };

        const handleCheck = async () => {
            if (isThinking) return;
            const img = canvasRef.current.toDataURL('image/png');
            setMessages(prev => [...prev, { id: Date.now(), sender: 'user', image: img }]);
            setIsThinking(true);
            clearCanvas();
            const aiRes = await callGemini({ type: 'image', content: img });
            setMessages(prev => [...prev, { id: Date.now()+1, sender: 'ai', text: aiRes }]);
            setIsThinking(false);
        };

        const handleSendText = async () => {
            if (!inputText.trim() || isThinking) return;
            const txt = inputText;
            setInputText('');
            setMessages(prev => [...prev, { id: Date.now(), sender: 'user', text: txt }]);
            setIsThinking(true);
            const aiRes = await callGemini({ type: 'text', content: txt });
            setMessages(prev => [...prev, { id: Date.now()+1, sender: 'ai', text: aiRes }]);
            setIsThinking(false);
        };

        if (appState === 'setup') {
            return (
                <div className="flex flex-col h-full items-center justify-center p-4">
                    <div className="bg-white p-8 rounded-3xl shadow-xl w-full max-w-md">
                        <h1 className="text-2xl font-bold text-indigo-600 mb-2">FlowMath Setup</h1>
                        <p className="text-sm text-gray-500 mb-6">請上傳題目或輸入文字</p>
                        
                        <div className="space-y-4">
                            <div className="relative border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:bg-gray-50">
                                <input type="file" accept="image/*" onChange={handleImageUpload} className="absolute inset-0 opacity-0 w-full h-full cursor-pointer"/>
                                {problemContext.image ? <span className="text-indigo-600 font-bold">圖片已就緒</span> : <span className="text-gray-400">點擊上傳題目照片</span>}
                            </div>
                            <textarea 
                                className="w-full p-3 border rounded-xl h-24 text-sm" 
                                placeholder="或是輸入題目..." 
                                value={problemContext.text}
                                onChange={e => setProblemContext({...problemContext, text: e.target.value})}
                            />
                            <button 
                                onClick={startSession} 
                                disabled={!problemContext.text && !problemContext.image}
                                className="w-full py-3 bg-indigo-600 text-white rounded-xl font-bold disabled:opacity-50"
                            >
                                開始學習
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        return (
            <div className="flex flex-col h-full max-w-4xl mx-auto bg-white shadow-2xl relative">
                <div className="px-6 py-4 border-b flex justify-between items-center bg-white z-20">
                    <div className="font-bold text-lg text-slate-700">FlowMath</div>
                    <button onClick={() => setAppState('setup')} className="text-sm text-slate-500 bg-slate-100 px-3 py-1 rounded-full">新題目</button>
                </div>

                <div className="flex-1 overflow-y-auto p-6 space-y-6 bg-slate-50 touch-pan-y" style={{ paddingBottom: panelHeight + 120 }}>
                    <div className="bg-slate-100 p-4 rounded-xl border max-w-[90%]">
                        <div className="text-xs text-slate-400 font-bold mb-2">CONTEXT</div>
                        {problemContext.image && <img src={problemContext.image} className="max-w-full h-auto rounded mb-2 mix-blend-multiply"/>}
                        <p className="whitespace-pre-wrap">{problemContext.text}</p>
                    </div>

                    {messages.map(msg => (
                        <div key={msg.id} className={`flex flex-col ${msg.sender === 'user' ? 'items-end' : 'items-start'}`}>
                            <div className="text-[10px] text-slate-400 mb-1 px-1">{msg.sender === 'ai' ? 'AI Tutor' : 'You'}</div>
                            <div className={`max-w-[90%] p-4 rounded-2xl shadow-sm whitespace-pre-wrap ${msg.sender === 'ai' ? 'bg-white rounded-tl-none text-slate-800' : 'bg-indigo-50 rounded-tr-none border-indigo-100'}`}>
                                {msg.text}
                                {msg.image && <img src={msg.image} className="max-w-full h-auto mix-blend-multiply rounded border bg-white"/>}
                            </div>
                        </div>
                    ))}
                    {isThinking && <div className="p-4 bg-white rounded-2xl rounded-tl-none shadow-sm w-16 flex gap-1"><div className="w-2 h-2 bg-indigo-400 rounded-full animate-bounce"/><div className="w-2 h-2 bg-indigo-400 rounded-full animate-bounce delay-75"/></div>}
                </div>

                <div className="absolute bottom-0 left-0 right-0 bg-white shadow-[0_-8px_30px_rgba(0,0,0,0.1)] rounded-t-3xl z-30 flex flex-col" style={{ height: inputMode === 'canvas' ? panelHeight : 'auto' }}>
                    {inputMode === 'canvas' && (
                        <div className="w-full h-8 flex justify-center items-center cursor-ns-resize touch-none"
                            onTouchStart={handleDragStart} onTouchMove={handleDragMove} onTouchEnd={handleDragEnd}
                            onMouseDown={handleDragStart} onMouseMove={handleDragMove} onMouseUp={handleDragEnd}
                        >
                            <div className="w-12 h-1.5 bg-slate-300 rounded-full"/>
                        </div>
                    )}

                    <div className="px-6 py-2 flex justify-between items-center border-b">
                        <div className="flex bg-slate-100 p-1 rounded-lg">
                            <button onClick={() => setInputMode('text')} className={`px-3 py-2 rounded-md text-sm font-bold flex gap-2 ${inputMode==='text'?'bg-white text-indigo-600 shadow-sm':'text-slate-400'}`}><Icon name="keyboard" size={16}/> 文字</button>
                            <button onClick={() => setInputMode('canvas')} className={`px-3 py-2 rounded-md text-sm font-bold flex gap-2 ${inputMode==='canvas'?'bg-white text-indigo-600 shadow-sm':'text-slate-400'}`}><Icon name="pen" size={16}/> 畫布</button>
                        </div>
                        {inputMode === 'canvas' && (
                            <div className="flex gap-2">
                                <button onClick={() => {setTool('pen'); setBrushColor('#1e293b')}} className={`p-2 rounded-full ${tool==='pen'&&brushColor==='#1e293b'?'bg-slate-100 text-indigo-600':'text-slate-400'}`}><Icon name="pen" size={18}/></button>
                                <button onClick={() => {setTool('pen'); setBrushColor('#ef4444')}} className={`p-2 rounded-full ${tool==='pen'&&brushColor==='#ef4444'?'bg-red-50 text-red-500':'text-slate-400'}`}><div className="w-4 h-4 bg-red-500 rounded-full"/></button>
                                <button onClick={() => setTool('eraser')} className={`p-2 rounded-full ${tool==='eraser'?'bg-slate-100 text-indigo-600':'text-slate-400'}`}><Icon name="eraser" size={18}/></button>
                                <button onClick={clearCanvas} className="p-2 text-slate-400 hover:text-red-500"><Icon name="refresh" size={18}/></button>
                                <div className="ml-2 flex items-center gap-1 text-xs text-slate-500">
                                    <span className="hidden sm:inline">畫布高度</span>
                                    <button onClick={() => setPanelHeight(240)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">S</button>
                                    <button onClick={() => setPanelHeight(320)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">M</button>
                                    <button onClick={() => setPanelHeight(480)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">L</button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="relative flex-1 bg-white">
                        <div className={`absolute inset-0 transition-opacity ${inputMode==='canvas'?'opacity-100 z-10':'opacity-0 z-0 pointer-events-none'}`}>
                            <div className="absolute inset-0 opacity-20 pointer-events-none" style={{backgroundImage: 'radial-gradient(#94a3b8 1px, transparent 1px)', backgroundSize: '24px 24px'}}/>
                            <canvas ref={canvasRef} className="w-full h-full cursor-crosshair touch-none"
                                onMouseDown={startDrawing} onMouseMove={draw} onMouseUp={stopDrawing} onMouseLeave={stopDrawing}
                                onTouchStart={startDrawing} onTouchMove={draw} onTouchEnd={stopDrawing}
                            />
                            <button onClick={handleCheck} disabled={isThinking} className="absolute bottom-6 right-6 bg-indigo-600 text-white px-6 py-3 rounded-2xl font-bold shadow-lg flex items-center gap-2 hover:bg-indigo-700 disabled:bg-slate-200 disabled:text-slate-400">
                                {isThinking ? '思考中...' : <span>Check <Icon name="chevronRight" className="inline"/></span>}
                            </button>
                        </div>

                        {inputMode === 'text' && (
                            <div className="relative w-full h-full p-6 flex gap-3 bg-white z-20 min-h-[140px]">
                                <textarea value={inputText} onChange={e=>setInputText(e.target.value)} className="flex-1 bg-slate-50 border rounded-xl p-4 resize-none h-32 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="輸入問題..."/>
                                <button onClick={handleSendText} disabled={!inputText.trim()||isThinking} className="bg-indigo-600 text-white p-4 rounded-xl shadow-lg hover:bg-indigo-700 disabled:bg-slate-200 h-16 self-end">
                                    <Icon name="send" size={24}/>
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<FlowMathApp />);
</script>


</body>
</html>
