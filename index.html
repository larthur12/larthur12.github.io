<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FlowMath - AI Mastery System</title>
    
    <!-- 1. 引入 Tailwind CSS (美化樣式) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- 3. 引入 Babel (讓瀏覽器看懂 React代碼) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. 引入 Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* 禁止 iOS 橡皮筋捲動效果 */
        body { overscroll-behavior-y: none; }
        /* 隱藏捲軸但保留功能 */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 h-screen overflow-hidden">
    
    <!-- React 應用程式掛載點 -->
    <div id="root"></div>

    <!-- 你的 FlowMath 完整程式碼 -->
    <script type="text/babel">
        // ==========================================
        // 重要：請在這裡填入你的 Google Gemini API Key
        // ==========================================
        const apiKey = "AIzaSyBJrpted3kQFGCQsaqfw-eHxAZ_R4VSTqY"; // <--- 貼在雙引號中間
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";

        const { useState, useRef, useEffect } = React;

        // --- 簡單的 Icon 組件 (使用 SVG 避免依賴) ---
        const Icon = ({ name, size = 20, className = "" }) => {
            // 修正：將多個路徑的 icon 用 <>...</> (Fragment) 包起來
            const icons = {
                pen: <path d="M12 19l7-7 3 3-7 7-3-3zM18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z M2 2l7.586 7.586" />,
                eraser: <path d="M2.998 2.998A2 2 0 014.808 2h14.384a2 2 0 011.81 1.002l-8.598 17.196A2 2 0 0110.8 21H2.998a1 1 0 01-.81-1.002L6.586 11l-4.398-8.002z M7 12h8" />,
                check: <polyline points="20 6 9 17 4 12" />,
                chevronRight: <polyline points="9 18 15 12 9 6" />,
                refresh: <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" />,
                camera: <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />,
                play: <polygon points="5 3 19 12 5 21 5 3" />,
                send: <><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></>,
                keyboard: <><rect x="2" y="4" width="20" height="16" rx="2" ry="2" /><line x1="6" y1="8" x2="6" y2="8" /><line x1="10" y1="8" x2="10" y2="8" /><line x1="14" y1="8" x2="14" y2="8" /><line x1="18" y1="8" x2="18" y2="8" /><line x1="6" y1="12" x2="6" y2="12" /><line x1="10" y1="12" x2="10" y2="12" /><line x1="14" y1="12" x2="14" y2="12" /><line x1="18" y1="12" x2="18" y2="12" /><line x1="7" y1="16" x2="17" y2="16" /></>,
                grip: <><circle cx="12" cy="12" r="1" /><circle cx="19" cy="12" r="1" /><circle cx="5" cy="12" r="1" /></>
            };
            
            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round"
                    className={className}
                >
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        // --- System Prompt ---
        const SYSTEM_PROMPT = `
        You are FlowMath, an expert Socratic Math Tutor.
        Goal: Help student solve math problems using Text Discussion + Handwriting Analysis.
        [MODE 1: TEXT] Explain concepts simply. Use analogies.
        [MODE 2: HANDWRITING] Analyze steps. Identify logical errors. Do NOT give answers directly. Ask guiding questions.
        Keep responses concise (under 3 sentences).
        `;

        const FlowMathApp = () => {
            const [appState, setAppState] = useState('setup');
            const [problemContext, setProblemContext] = useState({ text: '', image: null });
            const [messages, setMessages] = useState([]);
            const [isThinking, setIsThinking] = useState(false);
            const [inputMode, setInputMode] = useState('canvas');
            const [inputText, setInputText] = useState('');
            const [panelHeight, setPanelHeight] = useState(320);
            const [tool, setTool] = useState('pen');
            const [brushColor, setBrushColor] = useState('#1e293b');
            const [isDrawing, setIsDrawing] = useState(false);

            const canvasRef = useRef(null);
            const ctxRef = useRef(null);
            const isDraggingPanel = useRef(false);
            const dragStartY = useRef(0);
            const dragStartHeight = useRef(0);
            const savedCanvasDataRef = useRef(null);

            // --- API Call ---
            const callGemini = async (inputPayload) => {
                if (!apiKey) return "請先在 index.html 檔案中填入您的 API Key！";
                try {
                    const historyPrompt = messages.slice(-6).map(m => 
                        \`\${m.sender === 'user' ? 'Student' : 'Tutor'}: \${m.text || '[Image]'}\`
                    ).join('\\n');

                    const fullPrompt = \`
                    [Problem]: \${problemContext.text}
                    \${problemContext.image ? '[Image Attached]' : ''}
                    [History]:
                    \${historyPrompt}
                    \`;

                    const contentsParts = [{ text: fullPrompt }];

                    if (messages.length === 0 && problemContext.image) {
                        const base64Context = problemContext.image.split(',')[1];
                        contentsParts.push({ inlineData: { mimeType: "image/png", data: base64Context } });
                    }

                    if (inputPayload.type === 'text') {
                        contentsParts.push({ text: \`[Question]: \${inputPayload.content}\` });
                    } else {
                        const base64Handwriting = inputPayload.content.split(',')[1];
                        contentsParts.push({ text: \`[Handwriting]:\` });
                        contentsParts.push({ inlineData: { mimeType: "image/png", data: base64Handwriting } });
                    }

                    const response = await fetch(
                        \`https://generativelanguage.googleapis.com/v1beta/models/\${MODEL_NAME}:generateContent?key=\${apiKey}\`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: contentsParts }],
                                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] }
                            })
                        }
                    );

                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "抱歉，請再試一次。";
                } catch (error) {
                    console.error("AI Error:", error);
                    return "連線錯誤或 API Key 無效。";
                }
            };

            // --- Setup Logic ---
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => setProblemContext(prev => ({ ...prev, image: reader.result }));
                    reader.readAsDataURL(file);
                }
            };

            const startSession = () => {
                setMessages([{
                    id: 'init',
                    sender: 'ai',
                    text: '收到題目了！切換到「畫布模式」開始解題，或用「文字模式」討論觀念。',
                }]);
                setAppState('chat');
            };

            // --- Panel Resize ---
            const handleDragStart = (e) => {
                isDraggingPanel.current = true;
                dragStartY.current = e.touches ? e.touches[0].clientY : e.clientY;
                dragStartHeight.current = panelHeight;
                if (canvasRef.current && ctxRef.current) {
                    savedCanvasDataRef.current = ctxRef.current.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
                }
            };

            const handleDragMove = (e) => {
                if (!isDraggingPanel.current) return;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const deltaY = dragStartY.current - clientY;
                const newHeight = Math.min(Math.max(dragStartHeight.current + deltaY, 200), window.innerHeight * 0.8);
                setPanelHeight(newHeight);
            };

            const handleDragEnd = () => { isDraggingPanel.current = false; };

            // --- Drawing Logic ---
            useEffect(() => {
                if (appState !== 'chat' || inputMode !== 'canvas') return;
                const timer = setTimeout(() => {
                    const canvas = canvasRef.current;
                    if (!canvas) return;
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();

                    if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
                         let tempSavedData = savedCanvasDataRef.current;
                         if (!isDraggingPanel.current && !tempSavedData && ctxRef.current) {
                            try { tempSavedData = ctxRef.current.getImageData(0, 0, canvas.width, canvas.height); } catch(e){}
                         }
                         canvas.width = rect.width * dpr;
                         canvas.height = rect.height * dpr;
                         const ctx = canvas.getContext('2d');
                         ctx.scale(dpr, dpr);
                         ctx.lineCap = 'round';
                         ctx.lineJoin = 'round';
                         ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : brushColor;
                         ctx.lineWidth = tool === 'eraser' ? 20 : 3;
                         ctxRef.current = ctx;
                         if (tempSavedData) ctx.putImageData(tempSavedData, 0, 0);
                    } else if (!ctxRef.current) {
                        const ctx = canvas.getContext('2d');
                        ctx.scale(dpr, dpr);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.strokeStyle = brushColor;
                        ctx.lineWidth = 3;
                        ctxRef.current = ctx;
                    }
                    if (!isDraggingPanel.current) savedCanvasDataRef.current = null;
                }, 10);
                return () => clearTimeout(timer);
            }, [appState, inputMode, panelHeight, tool, brushColor]);

            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: cx - rect.left, y: cy - rect.top };
            };

            const startDrawing = (e) => {
                const { x, y } = getPos(e.nativeEvent || e);
                ctxRef.current.beginPath();
                ctxRef.current.moveTo(x, y);
                setIsDrawing(true);
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const { x, y } = getPos(e.nativeEvent || e);
                ctxRef.current.lineTo(x, y);
                ctxRef.current.stroke();
            };

            const stopDrawing = () => {
                if (ctxRef.current) ctxRef.current.closePath();
                setIsDrawing(false);
            };

            const clearCanvas = () => {
                const ctx = ctxRef.current;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                savedCanvasDataRef.current = null;
            };

            // --- Send Actions ---
            const handleCheck = async () => {
                if (isThinking) return;
                const img = canvasRef.current.toDataURL('image/png');
                setMessages(prev => [...prev, { id: Date.now(), sender: 'user', image: img }]);
                setIsThinking(true);
                clearCanvas();
                const aiRes = await callGemini({ type: 'image', content: img });
                setMessages(prev => [...prev, { id: Date.now()+1, sender: 'ai', text: aiRes }]);
                setIsThinking(false);
            };

            const handleSendText = async () => {
                if (!inputText.trim() || isThinking) return;
                const txt = inputText;
                setInputText('');
                setMessages(prev => [...prev, { id: Date.now(), sender: 'user', text: txt }]);
                setIsThinking(true);
                const aiRes = await callGemini({ type: 'text', content: txt });
                setMessages(prev => [...prev, { id: Date.now()+1, sender: 'ai', text: aiRes }]);
                setIsThinking(false);
            };

            // --- Render ---
            if (appState === 'setup') {
                return (
                    <div className="flex flex-col h-full items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-3xl shadow-xl w-full max-w-md">
                            <h1 className="text-2xl font-bold text-indigo-600 mb-2">FlowMath Setup</h1>
                            <p className="text-sm text-gray-500 mb-6">請上傳題目或輸入文字</p>
                            
                            <div className="space-y-4">
                                <div className="relative border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:bg-gray-50">
                                    <input type="file" accept="image/*" onChange={handleImageUpload} className="absolute inset-0 opacity-0 w-full h-full cursor-pointer"/>
                                    {problemContext.image ? <span className="text-indigo-600 font-bold">圖片已就緒</span> : <span className="text-gray-400">點擊上傳題目照片</span>}
                                </div>
                                <textarea 
                                    className="w-full p-3 border rounded-xl h-24 text-sm" 
                                    placeholder="或是輸入題目..." 
                                    value={problemContext.text}
                                    onChange={e => setProblemContext({...problemContext, text: e.target.value})}
                                />
                                <button 
                                    onClick={startSession} 
                                    disabled={!problemContext.text && !problemContext.image}
                                    className="w-full py-3 bg-indigo-600 text-white rounded-xl font-bold disabled:opacity-50"
                                >
                                    開始學習
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full max-w-4xl mx-auto bg-white shadow-2xl relative">
                    {/* Header */}
                    <div className="px-6 py-4 border-b flex justify-between items-center bg-white z-20">
                        <div className="font-bold text-lg text-slate-700">FlowMath</div>
                        <button onClick={() => setAppState('setup')} className="text-sm text-slate-500 bg-slate-100 px-3 py-1 rounded-full">新題目</button>
                    </div>

                    {/* Messages */}
                    <div className="flex-1 overflow-y-auto p-6 space-y-6 pb-64 bg-slate-50" style={{ paddingBottom: panelHeight + 40 }}>
                         {/* Context */}
                        <div className="bg-slate-100 p-4 rounded-xl border max-w-[90%]">
                            <div className="text-xs text-slate-400 font-bold mb-2">CONTEXT</div>
                            {problemContext.image && <img src={problemContext.image} className="max-w-full h-auto rounded mb-2 mix-blend-multiply"/>}
                            <p className="whitespace-pre-wrap">{problemContext.text}</p>
                        </div>

                        {messages.map(msg => (
                            <div key={msg.id} className={\`flex flex-col \${msg.sender === 'user' ? 'items-end' : 'items-start'}\`}>
                                <div className="text-[10px] text-slate-400 mb-1 px-1">{msg.sender === 'ai' ? 'AI Tutor' : 'You'}</div>
                                <div className={\`max-w-[90%] p-4 rounded-2xl shadow-sm whitespace-pre-wrap \${msg.sender === 'ai' ? 'bg-white rounded-tl-none text-slate-800' : 'bg-indigo-50 rounded-tr-none border-indigo-100'}\`}>
                                    {msg.text}
                                    {msg.image && <img src={msg.image} className="max-w-full h-auto mix-blend-multiply rounded border bg-white"/>}
                                </div>
                            </div>
                        ))}
                        {isThinking && <div className="p-4 bg-white rounded-2xl rounded-tl-none shadow-sm w-16 flex gap-1"><div className="w-2 h-2 bg-indigo-400 rounded-full animate-bounce"/><div className="w-2 h-2 bg-indigo-400 rounded-full animate-bounce delay-75"/></div>}
                    </div>

                    {/* Resizable Panel */}
                    <div className="absolute bottom-0 left-0 right-0 bg-white shadow-[0_-8px_30px_rgba(0,0,0,0.1)] rounded-t-3xl z-30 flex flex-col" style={{ height: inputMode === 'canvas' ? panelHeight : 'auto' }}>
                        
                        {/* Drag Handle */}
                        {inputMode === 'canvas' && (
                            <div className="w-full h-8 flex justify-center items-center cursor-ns-resize touch-none"
                                onTouchStart={handleDragStart} onTouchMove={handleDragMove} onTouchEnd={handleDragEnd}
                                onMouseDown={handleDragStart} onMouseMove={handleDragMove} onMouseUp={handleDragEnd}
                            >
                                <div className="w-12 h-1.5 bg-slate-300 rounded-full"/>
                            </div>
                        )}

                        {/* Tools & Toggle */}
                        <div className="px-6 py-2 flex justify-between items-center border-b">
                            <div className="flex bg-slate-100 p-1 rounded-lg">
                                <button onClick={() => setInputMode('text')} className={\`px-3 py-2 rounded-md text-sm font-bold flex gap-2 \${inputMode==='text'?'bg-white text-indigo-600 shadow-sm':'text-slate-400'}\`}><Icon name="keyboard" size={16}/> 文字</button>
                                <button onClick={() => setInputMode('canvas')} className={\`px-3 py-2 rounded-md text-sm font-bold flex gap-2 \${inputMode==='canvas'?'bg-white text-indigo-600 shadow-sm':'text-slate-400'}\`}><Icon name="pen" size={16}/> 畫布</button>
                            </div>
                            {inputMode === 'canvas' && (
                                <div className="flex gap-2">
                                    <button onClick={() => {setTool('pen'); setBrushColor('#1e293b')}} className={\`p-2 rounded-full \${tool==='pen'&&brushColor==='#1e293b'?'bg-slate-100 text-indigo-600':'text-slate-400'}\`}><Icon name="pen" size={18}/></button>
                                    <button onClick={() => {setTool('pen'); setBrushColor('#ef4444')}} className={\`p-2 rounded-full \${tool==='pen'&&brushColor==='#ef4444'?'bg-red-50 text-red-500':'text-slate-400'}\`}><div className="w-4 h-4 bg-red-500 rounded-full"/></button>
                                    <button onClick={() => setTool('eraser')} className={\`p-2 rounded-full \${tool==='eraser'?'bg-slate-100 text-indigo-600':'text-slate-400'}\`}><Icon name="eraser" size={18}/></button>
                                    <button onClick={clearCanvas} className="p-2 text-slate-400 hover:text-red-500"><Icon name="refresh" size={18}/></button>
                                </div>
                            )}
                        </div>

                        {/* Content */}
                        <div className="relative flex-1 bg-white">
                            {/* Canvas */}
                            <div className={\`absolute inset-0 transition-opacity \${inputMode==='canvas'?'opacity-100 z-10':'opacity-0 z-0 pointer-events-none'}\`}>
                                <div className="absolute inset-0 opacity-20 pointer-events-none" style={{backgroundImage: 'radial-gradient(#94a3b8 1px, transparent 1px)', backgroundSize: '24px 24px'}}/>
                                <canvas ref={canvasRef} className="w-full h-full cursor-crosshair touch-none"
                                    onMouseDown={startDrawing} onMouseMove={draw} onMouseUp={stopDrawing} onMouseLeave={stopDrawing}
                                    onTouchStart={startDrawing} onTouchMove={draw} onTouchEnd={stopDrawing}
                                />
                                <button onClick={handleCheck} disabled={isThinking} className="absolute bottom-6 right-6 bg-indigo-600 text-white px-6 py-3 rounded-2xl font-bold shadow-lg flex items-center gap-2 hover:bg-indigo-700 disabled:bg-slate-200 disabled:text-slate-400">
                                    {isThinking ? '思考中...' : <span>Check <Icon name="chevronRight" className="inline"/></span>}
                                </button>
                            </div>

                            {/* Text */}
                            {inputMode === 'text' && (
                                <div className="absolute inset-0 p-6 flex gap-3 bg-white z-20">
                                    <textarea value={inputText} onChange={e=>setInputText(e.target.value)} className="flex-1 bg-slate-50 border rounded-xl p-4 resize-none h-32 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="輸入問題..."/>
                                    <button onClick={handleSendText} disabled={!inputText.trim()||isThinking} className="bg-indigo-600 text-white p-4 rounded-xl shadow-lg hover:bg-indigo-700 disabled:bg-slate-200">
                                        <Icon name="send" size={24}/>
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FlowMathApp />);
    </script>
</body>
</html>